<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake — Time Attack</title>
  <style>
    :root {
      --bg: #0f1220; --panel:#171a2b; --fg:#e6e9f2; --accent:#6ee7ff; --danger:#ff5a7a;
      --grid:#22263c; --snake:#8ef78e; --snake-head:#7be57b;
      --food:#ffd166; --food-fast:#fca5a5; --food-slow:#7dd3fc;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin:0; display:grid; place-items:center; background: radial-gradient(1200px 900px at 50% 10%, #13162a, var(--bg)); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap { width: min(92vw, 580px); }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.08); border-radius:18px; padding:16px 16px 20px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    h1 { font-size:20px; margin:0 0 8px; letter-spacing:.3px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
    .meta { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin:8px 0 10px; }
    .box { background: var(--panel); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:8px 10px; display:flex; align-items:center; justify-content:space-between; font-variant-numeric: tabular-nums; }
    .label { opacity:.8; font-size:12px; }
    button { background: var(--panel); border:1px solid rgba(255,255,255,0.12); color:var(--fg); padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:600; letter-spacing:.2px; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.primary { background: linear-gradient(180deg, #1b2038, #161a2e); border-color: rgba(110,231,255,.35); }
    canvas { width:100%; height:auto; border-radius:14px; display:block; background: linear-gradient(180deg, #0e1121, #0b0e1a); border:1px solid rgba(255,255,255,0.08); }
    .hint { opacity:.75; font-size:12px; margin-top:6px; text-align:center; }
    select { background: var(--panel); color:var(--fg); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:6px 10px; }
    .bad { color: var(--danger); }
    .pill { padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14); font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <h1>Snake — Time Attack (目標 1000点)</h1>
        <label class="row" style="gap:6px">
          <span class="label">初期スピード</span>
          <select id="baseSpeed"></select>
          <span class="pill" id="currentSpeed">Speed: 10</span>
        </label>
      </div>

      <div class="meta">
        <div class="box"><span class="label">ベストスコア</span><strong id="bestScore">0</strong></div>
        <div class="box"><span class="label">最速1000点タイム</span><strong id="bestTime">—</strong></div>
        <div class="box"><span class="label">スコア</span><strong><span id="score">0</span> / 1000</strong></div>
        <div class="box"><span class="label">ゲームタイマー</span><strong id="gameTimer">0.0s</strong></div>
        <div class="box"><span class="label">効果タイマー</span><strong id="effectTimer">—</strong></div>
        <div class="box"><span class="label">状態</span><strong id="status">Ready</strong></div>
      </div>

      <canvas id="game" width="420" height="420" aria-label="Snake board" role="img"></canvas>

      <div class="row" style="justify-content:center; margin-top:10px;">
        <button id="start" class="primary">▶ Start / Restart</button>
        <button id="btnClear">🧹 記録クリア</button>
        <button id="btnList">📜 最近のスコア</button>
        <button id="btnTop">🏆 ベスト10</button>
        <label class="row" style="gap:8px; align-items:center;">
          <input type="checkbox" id="showGrid" /> <span class="label">グリッド表示</span>
        </label>
      </div>

      <div class="hint">操作: ← ↑ → ↓ / WASD ・ リスタート</div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const statusEl = document.getElementById('status');
      const showGrid = document.getElementById('showGrid');
      const startBtn = document.getElementById('start');
      const btnClear = document.getElementById('btnClear');
      const btnList  = document.getElementById('btnList');
      const btnTop   = document.getElementById('btnTop');
      const gameTimerEl = document.getElementById('gameTimer');
      const effectTimerEl = document.getElementById('effectTimer');
      const baseSpeedSel = document.getElementById('baseSpeed');
      const currentSpeedEl = document.getElementById('currentSpeed');
      const STORAGE = {
        bestScore: 'snakeBestScore',
        bestTimeMs: 'snakeBestTimeMs',
        records: 'snakeRecords' 
    };
    let bestScore = +(localStorage.getItem(STORAGE.bestScore) || 0);
    let bestTimeMs = +(localStorage.getItem(STORAGE.bestTimeMs) || 0); // 0は未記録

      // Populate base speed selector (6..20)
      const savedBase = +localStorage.getItem('snakeBaseSpeed') || 10;
      for (let s=6; s<=20; s++) {
        const opt = document.createElement('option');
        opt.value = s; opt.textContent = s;
        if (s === savedBase) opt.selected = true;
        baseSpeedSel.appendChild(opt);
      }

      // Board settings
      const COLS = 21, ROWS = 21;
      const CELL = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
      const W = CELL * COLS, H = CELL * ROWS;
      canvas.width = W; canvas.height = H;

      const DIR = { LEFT:{x:-1,y:0,key:['ArrowLeft','a','A']}, UP:{x:0,y:-1,key:['ArrowUp','w','W']}, RIGHT:{x:1,y:0,key:['ArrowRight','d','D']}, DOWN:{x:0,y:1,key:['ArrowDown','s','S']} };

      // Food config
      const FOOD_TYPES = {
        normal: { color: getVar('--food'), points:20, effect: null },
        fast:   { color: getVar('--food-fast'), points:50, effect: {delta:+5, duration:3000} },
        slow:   { color: getVar('--food-slow'), points:30, effect: {delta:-5, duration:3000} },
      };

      let snake, dir, nextDir, foods, score, baseSpeed, speed, playing, dead;
      let effectUntil = 0, effectDelta = 0; // effect timer in ms deadline and delta
      let startTime = 0; // game start timestamp (ms)
      let last = performance.now(), accumulator = 0; // for movement

      function initState() {
        baseSpeed = +baseSpeedSel.value || 10;
        localStorage.setItem('snakeBaseSpeed', baseSpeed);
        speed = baseSpeed; updateSpeedBadge();
        snake = [ {x: Math.floor(COLS/2)+1, y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2)} ];
        dir = DIR.RIGHT; nextDir = DIR.RIGHT;
        score = 0; updateScore();
        foods = spawnInitialFoods();
        effectUntil = 0; effectDelta = 0; updateEffectTimer();
        playing = false; dead = false; accumulator = 0;
        statusEl.textContent = 'Ready';
        updateGameTimer(0);
      }

      function spawnInitialFoods() {
        // 3 normal, 1 fast, 1 slow
        const arr = [];
        const pushType = (type, count) => { for(let i=0;i<count;i++) arr.push(spawnFood(type, arr)); };
        pushType('normal', 10);
        pushType('fast', 3);
        pushType('slow', 3);
        return arr;
      }

      function randomEmptyCell(avoid=[]) {
        let x,y,collides;
        do {
          x = Math.floor(Math.random()*COLS);
          y = Math.floor(Math.random()*ROWS);
          collides = snake.some(s=>s.x===x && s.y===y) || avoid.some(f=>f.x===x && f.y===y);
        } while(collides);
        return {x,y};
      }

      function spawnFood(type, existing) {
        const pos = randomEmptyCell(existing ?? foods ?? []);
        return { type, x: pos.x, y: pos.y };
      }

      function maintainFoodCounts() {
        const counts = {normal:0, fast:0, slow:0};
        foods.forEach(f=>counts[f.type]++);
        const need = { normal: Math.max(0, 5 - counts.normal), fast: Math.max(0, 2 - counts.fast), slow: Math.max(0, 2 - counts.slow) };
        if (need.normal) for(let i=0;i<need.normal;i++) foods.push(spawnFood('normal'));
        if (need.fast) for(let i=0;i<need.fast;i++) foods.push(spawnFood('fast'));
        if (need.slow) for(let i=0;i<need.slow;i++) foods.push(spawnFood('slow'));
      }

      function setDirection(newDir) {
        if ((dir===DIR.LEFT && newDir===DIR.RIGHT) || (dir===DIR.RIGHT && newDir===DIR.LEFT) || (dir===DIR.UP && newDir===DIR.DOWN) || (dir===DIR.DOWN && newDir===DIR.UP)) return;
        nextDir = newDir;
      }

      function fmtSec(ms){ return (ms/1000).toFixed(1) + 's'; }
      function updateBestUI(){
        const bestScoreEl = document.getElementById('bestScore');
        const bestTimeEl  = document.getElementById('bestTime');
        if (bestScoreEl) bestScoreEl.textContent = String(bestScore);
        if (bestTimeEl)  bestTimeEl.textContent  = bestTimeMs ? fmtSec(bestTimeMs) : '—';
      }

      window.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowLeft': case 'a': case 'A': setDirection(DIR.LEFT); break;
          case 'ArrowUp': case 'w': case 'W': setDirection(DIR.UP); break;
          case 'ArrowRight': case 'd': case 'D': setDirection(DIR.RIGHT); break;
          case 'ArrowDown': case 's': case 'S': setDirection(DIR.DOWN); break;
        }
      }, {passive:true});

      startBtn.addEventListener('click', () => {
        // Start or Restart
        initState();
        playing = true; statusEl.textContent = 'Playing';
        startTime = performance.now();
      });

      btnClear?.addEventListener('click', () => {
        if (confirm('ローカル記録（ベスト・履歴）をすべて削除します。よろしいですか？')) {
          clearLocalRecords();
          alert('削除しました');
        }
      });
      btnList?.addEventListener('click', showRecords);
      btnTop?.addEventListener('click', showLeaderboard);

      baseSpeedSel.addEventListener('change', () => {
        // Save preference immediately; will apply next Start
        const val = +baseSpeedSel.value; localStorage.setItem('snakeBaseSpeed', val);
        if (!playing && !dead) { currentSpeedEl.textContent = `Speed: ${val}`; }
      });

      function updateSpeedBadge(){ currentSpeedEl.textContent = `Speed: ${speed}`; }
      function updateScore(){ scoreEl.textContent = score; }
      function updateGameTimer(ms){ gameTimerEl.textContent = (ms/1000).toFixed(1)+"s"; }
      function updateEffectTimer(){
        if (effectUntil > performance.now()) {
          const remain = Math.max(0, effectUntil - performance.now());
          effectTimerEl.textContent = (remain/1000).toFixed(1)+"s";
        } else {
          effectTimerEl.textContent = '—';
        }
      }

      function applyEffect(effect) {
        if (!effect) return;
        effectDelta = effect.delta; // override with latest effect
        effectUntil = performance.now() + effect.duration;
        speed = clamp(baseSpeed + effectDelta, 2, 30);
        updateSpeedBadge();
      }

      function clearEffectIfExpired() {
        if (effectUntil && performance.now() >= effectUntil) {
          effectUntil = 0; effectDelta = 0; speed = baseSpeed; updateSpeedBadge();
        }
      }

      function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
      function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

      function tick() {
        dir = nextDir;
        const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
        if (head.x<0 || head.x>=COLS || head.y<0 || head.y>=ROWS) { return gameOver(); }
        if (snake.some((s,i)=> i>0 && s.x===head.x && s.y===head.y)) { return gameOver(); }

        snake.unshift(head);

        // Eat check
        const idx = foods.findIndex(f=> f.x===head.x && f.y===head.y);
        if (idx !== -1) {
          const f = foods.splice(idx,1)[0];
          const cfg = FOOD_TYPES[f.type];
          score += cfg.points; updateScore();
          if (cfg.effect) applyEffect(cfg.effect);
          maintainFoodCounts();
          if (score >= 1000) { score = 1000; return victory(); }
        } else {
          snake.pop();
        }
      }

      function getRecords(){
        try { return JSON.parse(localStorage.getItem(STORAGE.records) || '[]'); }
        catch { return []; }
      }
      function saveRecords(arr){
        localStorage.setItem(STORAGE.records, JSON.stringify(arr));
      }
      function addRecord(score, elapsedMs, win){
        const recs = getRecords();
        recs.push({
          score,
          timeMs: Math.max(0, Math.floor(elapsedMs||0)),
          win: !!win,
          at: new Date().toISOString()
        });
        saveRecords(recs);
      }

      // 追加：一覧表示（新しい順）
      function showRecords(){
        const recs = getRecords().slice().reverse();
        if (recs.length === 0) { alert('記録はまだありません'); return; }
        const lines = recs.map((r,i)=> {
          const t = fmtSec(r.timeMs);
          const d = r.at.replace('T',' ').slice(0,19);
          return `${i+1}. ${r.score}点 / ${t} / ${r.win?'WIN':'LOSE'} / ${d}`;
        });
        alert(lines.join('\n'));
      }

      // 追加：ベスト10（スコア降順→同点は時間昇順）
      function showLeaderboard(){
        const top = getRecords()
          .slice()
          .sort((a,b)=> (b.score - a.score) || (a.timeMs - b.timeMs))
          .slice(0,10);
        if (top.length === 0) { alert('記録はまだありません'); return; }
        const lines = top.map((r,i)=> `${i+1}. ${r.score}点 / ${fmtSec(r.timeMs)} / ${r.win?'WIN':'LOSE'}`);
        alert(lines.join('\n'));
      }

      function victory(){
        dead = true; playing = false;
        const elapsed = performance.now() - startTime;
        addRecord(score, elapsed, true);

        // ベストスコア更新
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem(STORAGE.bestScore, String(bestScore));
        }

        // 1000点達成タイムの最短更新（小さいほど良い）
        if (score >= 1000 && (bestTimeMs === 0 || elapsed < bestTimeMs)) {
          bestTimeMs = elapsed;
          localStorage.setItem(STORAGE.bestTimeMs, String(bestTimeMs));
        }

        updateBestUI();
        statusEl.textContent = '🎉 1000点達成!';
      } 
      function gameOver(){
        dead = true; playing = false;
        const elapsed = performance.now() - startTime;  // ← 追加（未定義なら追加）
        addRecord(score, elapsed, false);     

        // ベストスコア更新（達成未満でも上回れば保存）
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem(STORAGE.bestScore, String(bestScore));
          updateBestUI();
        }

        statusEl.innerHTML = '<span class="bad">Game Over</span>';
      }

      function clearLocalRecords(){
        localStorage.removeItem(STORAGE.bestScore);
        localStorage.removeItem(STORAGE.bestTimeMs);
        localStorage.removeItem(STORAGE.records); // ← 追加
        bestScore = 0; bestTimeMs = 0; updateBestUI();
      }

      function draw() {
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle = '#0b0e1a'; ctx.fillRect(0,0,W,H);
        if (showGrid.checked) drawGrid();

        // foods
        for (const f of foods) {
          const color = FOOD_TYPES[f.type].color;
          drawCell(f.x, f.y, 0.55, color);
        }

        // snake body
        for (let i = snake.length-1; i >= 1; i--) {
          const s = snake[i]; drawCell(s.x, s.y, 0.7, getVar('--snake'));
        }
        const head = snake[0];
        drawCell(head.x, head.y, 0.9, getVar('--snake-head'));
        drawEyes(head);
      }

      function drawGrid(){
        ctx.strokeStyle = getVar('--grid'); ctx.lineWidth = 1; ctx.beginPath();
        for (let x=0; x<=COLS; x++) { ctx.moveTo(x*CELL+0.5,0); ctx.lineTo(x*CELL+0.5,H); }
        for (let y=0; y<=ROWS; y++) { ctx.moveTo(0,y*CELL+0.5); ctx.lineTo(W,y*CELL+0.5); }
        ctx.stroke();
      }

      function drawCell(cx, cy, padScale, color){ const pad=(1-padScale)*CELL*0.5; ctx.fillStyle=color; ctx.fillRect(cx*CELL+pad, cy*CELL+pad, CELL-pad*2, CELL-pad*2); }
      function drawEyes(head){ const cx=head.x*CELL + CELL/2, cy=head.y*CELL + CELL/2; const ex=(dir.x!==0?dir.x:0)*(CELL*0.18), ey=(dir.y!==0?dir.y:0)*(CELL*0.18); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.beginPath(); ctx.arc(cx-4+ex, cy-4+ey, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+4+ex, cy-4+ey, 3, 0, Math.PI*2); ctx.fill(); }

      function loop(now){
        const dt = now - last; last = now;
        if (playing && !dead) {
          // Real-time timers independent of speed
          updateGameTimer(now - startTime);
          clearEffectIfExpired(); updateEffectTimer();

          // Movement at variable speed (cells per second)
          const step = 1000 / speed; // ms per cell
          accumulator += dt;
          while (accumulator >= step) { accumulator -= step; tick(); }
        }
        draw();
        requestAnimationFrame(loop);
      }

      // --- Boot ---
      initState();
      
      updateBestUI();
      requestAnimationFrame((t)=>{ last=t; requestAnimationFrame(loop); });
    })();
  </script>
</body>
</html>